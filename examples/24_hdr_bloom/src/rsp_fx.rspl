include "rsp_queue.inc"

#define SCREEN_WIDTH 320
#define SCREEN_HEIGHT 240
#define SCREEN_STRIDE (SCREEN_WIDTH * 4)
#define BUFF_SIZE_RGBA16 (SCREEN_WIDTH * SCREEN_HEIGHT * 2)
#define BUFF_SIZE_RGBA32 (SCREEN_WIDTH * SCREEN_HEIGHT * 4)

#define BLUR_WIDTH 80
#define BLUR_HEIGHT 60
#define BLUR_STRIDE (BLUR_WIDTH * 4)

state
{
}

data
{
}

bss {
  u32 BUFF_IN_A[SCREEN_WIDTH];
  u32 BUFF_IN_B[SCREEN_WIDTH];

  alignas(8)
  u32 BUFF_BLOOM[BLUR_WIDTH];
  u32 BUFF_BLOOM_B[BLUR_WIDTH];
}

// DMA from RDRAM into DMEM
macro dmaInAsync(u32 addrRDRAM, u32 addrDMEM, u32 size)
{
  @Barrier("DMA") set_dma_addr_rsp(addrDMEM);
  @Barrier("DMA") set_dma_addr_rdram(addrRDRAM);
  @Barrier("DMA") set_dma_read(size);
}

// DMA from DMEM into RDRAM
macro dmaOutAsync(u32 addrRDRAM, u32 addrDMEM, u32 size)
{
  @Barrier("DMA") set_dma_addr_rsp(addrDMEM);
  @Barrier("DMA") set_dma_addr_rdram(addrRDRAM);
  @Barrier("DMA") set_dma_write(size);
}

 macro dmaAwait()
 {
   loop {
    RA = get_dma_busy();
    // DELAY SLOT
  } while(RA != 0)
 }

macro packRGBA16(vec16 out, vec16 in)
{
  in >>= 10;
  out = in * 2;
  out = VCONST_G +* in.yyyyYYYY;
  out = VCONST_R +* in.xxxxXXXX;
}

command<0> Cmd_HDRBloom(u32 ptrIn, u32 ptrOut, u32 ptrBloom, u16 factor)
{
  vec16 colFactor;
  colFactor.w = factor;

  vec16 VCONST_R = 1 << 11;
  vec16 VCONST_G = 1 << 6;

  dma_await();

  u32 ptrInEnd = ptrIn + BUFF_SIZE_RGBA32;
  u16 buffDMEM = BUFF_IN_A;
  u8 bloomPhase = 0;
  //ptrBloom -= 8;
  //ptrBloom += BLUR_STRIDE;

  vec16 bloomFactorA = 0;
  bloomFactorA:sfract.X = 0.25;
  bloomFactorA:sfract.Y = 0.25;
  bloomFactorA:sfract.Z = 0.25;

  vec16 bloomFactorB;
  bloomFactorB:sfract.x = 0.5;
  bloomFactorB:sfract.y = 0.5;
  bloomFactorB:sfract.z = 0.5;
  bloomFactorB:sfract.X = 0.75;
  bloomFactorB:sfract.Y = 0.75;
  bloomFactorB:sfract.Z = 0.75;

  loop {
    u32 dmaSize = SCREEN_STRIDE - 1;
    u32 ptrDMEM = buffDMEM;

    dmaInAsync(ptrIn, ptrDMEM, dmaSize);

    u16 dmemBloom = BUFF_BLOOM;
    u16 bloomDmaSize = BLUR_STRIDE*2;

    if(bloomPhase == 0) {
      loop {
        RA = get_dma_busy();
        bloomPhase = 4; // DELAY SLOT
      } while(RA != 0)

      dmaInAsync(ptrBloom, dmemBloom, bloomDmaSize);
      ptrBloom += BLUR_STRIDE;
    }
    bloomPhase -= 1;

    ptrIn += SCREEN_STRIDE;

    u32 dmemOut = BUFF_IN_B;
    u32 dmemIn = ptrDMEM;
    u32 dmemInEnd;

    bloomFactorA.W = 0;
    if(bloomPhase == 2)bloomFactorA:sfract.W = 0.25;
    if(bloomPhase == 1)bloomFactorA:sfract.W = 0.50;
    if(bloomPhase == 0)bloomFactorA:sfract.W = 0.75;

    loop {
      RA = get_dma_busy();
      // DELAY SLOT
      dmemInEnd = dmemIn + SCREEN_WIDTH*4;
    } while(RA != 0)

    loop {
      vec16 bloom0, bloom1, bloom2, bloom3;

      bloom0 = load_vec_u8(dmemBloom, 0);
      vec16 bloom0Next = load_vec_u8(dmemBloom, 320);
      vec16 diffY = bloom0Next - bloom0;

      // interpolate vertically
      bloom0:sint = bloom0:sint * 1;
      bloom0:sfract = diffY:sfract +* bloomFactorA:sfract.W;

      // bloom0 now contains 2 pixels in xyzw and XYZW, so viewing the register as two halves: [A, B]
      // in order to do horizontal interpolation we have to LERP 3 values in between A and B (X0, X1, X2)
      // and organize the data so that that span across 2 registers to be added onto the color value later on
      // So we need to transform [A,B] into [A, X0] [X1, X2], B gets thrown away since it is the next starting pixel
      @Barrier("tmp") store(bloom0, RSPQ_SCRATCH_MEM);
      @Barrier("tmp") bloom0.XYZW = load(RSPQ_SCRATCH_MEM).xyzw;
      @Barrier("tmp") bloom3.xyzw = load(RSPQ_SCRATCH_MEM).XYZW;
      @Barrier("tmp") bloom3.XYZW = load(RSPQ_SCRATCH_MEM).XYZW;

      vec16 diffX = bloom3 - bloom0;
      dmemBloom += 4;

      bloom0:sint = bloom0:sint * 1;
      bloom0:sfract = diffX:sfract +* bloomFactorA:sfract;

      bloom1:sint = bloom0:sint * 1;
      bloom1:sfract = diffX:sfract +* bloomFactorB:sfract;

      vec16 pixel0 = load_vec_u8(dmemIn, 0);
      vec16 pixel1 = load_vec_u8(dmemIn, 8);
      //vec16 pixel2 = load_vec_u8(dmemIn, 16);
      //vec16 pixel3 = load_vec_u8(dmemIn, 24);

      pixel0:sint += bloom0:sint;
      pixel1:sint += bloom1:sint;
      //pixel2:sint += bloom2:sint;
      //pixel3:sint += bloom3:sint;

      { // DEBUG:
        //pixel0:sint = bloom0:sint;
        //pixel1:sint = bloom1:sint;
        //pixel2:sint = bloom2:sint;
        //pixel3:sint = bloom3:sint;
      }

      pixel0 >>= 6;
      pixel1 >>= 6;
      //pixel2 >>= 6;
      //pixel3 >>= 6;

      pixel0:sint *= colFactor.w;
      pixel1:sint *= colFactor.w;
      //pixel2:sint *= colFactor.w;
      //pixel3:sint *= colFactor.w;

      vec16 pixelOut0 = packRGBA16(pixel0);
      vec16 pixelOut1 = packRGBA16(pixel1);
      //vec16 pixelOut2 = packRGBA16(pixel2);
      //vec16 pixelOut3 = packRGBA16(pixel3);

      store(pixelOut0.z, dmemOut, 0);
      store(pixelOut0.Z, dmemOut, 2);
      store(pixelOut1.z, dmemOut, 4);
      store(pixelOut1.Z, dmemOut, 6);
      /*store(pixelOut2.z, dmemOut, 8);
      store(pixelOut2.Z, dmemOut, 10);
      store(pixelOut3.z, dmemOut, 12);
      store(pixelOut3.Z, dmemOut, 14);*/

      dmemIn += 16;
      dmemOut += 8;
    } while(dmemIn != dmemInEnd)

    u32 dmaSize = (SCREEN_WIDTH * 2) - 1;
    ptrDMEM = dmemOut - SCREEN_WIDTH * 2;
    dmaOutAsync(ptrOut, ptrDMEM, dmaSize);

    ptrOut += (SCREEN_WIDTH * 2);
  } while(ptrIn != ptrInEnd)
}

macro loadNextImageLine(u32 ptrRDRAMIn, u16 dmaSize)
{
  u16 dmemInRow = dmemInOffset + BUFF_IN_A;
  dmaInAsync(ptrRDRAMIn, dmemInRow, dmaSize);
  dmemInOffset += BLUR_STRIDE;
  ptrRDRAMIn += BLUR_STRIDE;
  if(dmemInOffset == dmemInOffsetEnd) {
    dmemInOffset = 0;
  }
}

macro sum4x3(
  vec16 sum, vec16 factor,
  vec16 pixel00, vec16 pixel10, vec16 pixel20,
  vec16 pixel01, vec16 pixel11, vec16 pixel21
)
{
  sum:ufract = pixel00:ufract *  factor:ufract.x;
  sum:ufract = pixel10:ufract +* factor:ufract.x;
  sum:ufract = pixel20:ufract +* factor:ufract.x;

  sum:ufract = pixel01:ufract +* factor:ufract.x;
  sum:ufract = pixel11:ufract +* factor:ufract.x;
  sum:ufract = pixel21:ufract +* factor:ufract.x;
}

command<1> Cmd_Blur(u32 ptrRDRAMIn, u32 ptrRDRAMOut, u16 brightness)
{
  u32 ptrRDRAMInEnd = ptrRDRAMIn + (BLUR_STRIDE * (BLUR_HEIGHT+2));

  u16 dmaSize = (BLUR_WIDTH * 4) - 1;
  u16 dmemInOffset = 0;
  u16 dmemInOffsetEnd = BLUR_STRIDE * 3;

  // @TODO: use proper kernel(?) | uses 2 register(?)
  vec16 factor;
  factor.x = brightness;

  u16 dmemInA = BUFF_IN_A;
  u32 dmemOutStart = dmemInA + 2048;

  dmaAwait();

  ptrRDRAMIn += BLUR_STRIDE;
  dmaInAsync(ptrRDRAMIn, dmemInA, dmaSize);
  dmemInA += BLUR_STRIDE;

  dmaInAsync(ptrRDRAMIn, dmemInA, dmaSize);
  dmemInA += BLUR_STRIDE;
  dmaAwait();
  dmaInAsync(ptrRDRAMIn, dmemInA, dmaSize);
  dmemInA -= BLUR_STRIDE * 2;

  ptrRDRAMIn += BLUR_STRIDE*2;
  dmaAwait();

  /*{
    vec16 c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10,
          c11, c12, c13, c14, c15, c16, c17, c18, c19;
    c0 = load(dmemInA, 0);
    c1 = load(dmemInA, 16);
    c2 = load(dmemInA, 32);
    c3 = load(dmemInA, 48);
    c4 = load(dmemInA, 64);
    c5 = load(dmemInA, 80);
    c6 = load(dmemInA, 96);
    c7 = load(dmemInA, 112);
    c8 = load(dmemInA, 128);
    c9 = load(dmemInA, 144);
    c10 = load(dmemInA, 160);
    c11 = load(dmemInA, 176);
    c12 = load(dmemInA, 192);
    c13 = load(dmemInA, 208);
    c14 = load(dmemInA, 224);
    c15 = load(dmemInA, 240);
    c16 = load(dmemInA, 256);
    c17 = load(dmemInA, 272);
    c18 = load(dmemInA, 288);
    c19 = load(dmemInA, 304);
    AA:
    u16 tmpB = dmemInA + BLUR_STRIDE;
    u16 tmpC = dmemInA + BLUR_STRIDE;
    store(c0, tmpB, 0);  store(c0, tmpC, 0);
    store(c1, tmpB, 16);  store(c1, tmpC, 16);
    store(c2, tmpB, 32);  store(c2, tmpC, 32);
    store(c3, tmpB, 48);  store(c3, tmpC, 48);
    store(c4, tmpB, 64);  store(c4, tmpC, 64);
    store(c5, tmpB, 80);  store(c5, tmpC, 80);
    store(c6, tmpB, 96);  store(c6, tmpC, 96);
    store(c7, tmpB, 112);  store(c7, tmpC, 112);
    store(c8, tmpB, 128);  store(c8, tmpC, 128);
    store(c9, tmpB, 144);  store(c9, tmpC, 144);
    store(c10, tmpB, 160);  store(c10, tmpC, 160);
    store(c11, tmpB, 176);  store(c11, tmpC, 176);
    store(c12, tmpB, 192);  store(c12, tmpC, 192);
    store(c13, tmpB, 208);  store(c13, tmpC, 208);
    store(c14, tmpB, 224);  store(c14, tmpC, 224);
    store(c15, tmpB, 240);  store(c15, tmpC, 240);
    store(c16, tmpB, 256);  store(c16, tmpC, 256);
    store(c17, tmpB, 272);  store(c17, tmpC, 272);
    store(c18, tmpB, 288);  store(c18, tmpC, 288);
    store(c19, tmpB, 304);  store(c19, tmpC, 304);
  }*/

  loop {
    dmemInA = BUFF_IN_A;
    dmemInA -= 4;

    u16 dmemInC = dmemInA + BLUR_STRIDE*2;

    u32 dmemOutCurr, dmemOutEnd;

    loop {
      RA = get_dma_busy();
      dmemOutCurr = dmemOutStart; // DELAY SLOT
    } while(RA != 0)

    vec16 pixelA_00 = load_vec_u8(dmemInA, 0);
    vec16 pixelA_10 = load_vec_u8(dmemInA, 320);
    vec16 pixelA_20 = load_vec_u8(dmemInC, 0);

    vec16 pixelA_01 = load_vec_u8(dmemInA, 8);
    vec16 pixelA_11 = load_vec_u8(dmemInA, 328);

    loop {
      u16 dmemInB = dmemInA + BLUR_STRIDE*1;

      vec16 pixelA_21 = load_vec_u8(dmemInC, 8);

      vec16 pixelB_01 = load_vec_u8(dmemInA, 16);
      vec16 pixelB_11 = load_vec_u8(dmemInB, 16);
      vec16 pixelB_21 = load_vec_u8(dmemInC, 16);

      vec16 pixelF_01 = load_vec_u8(dmemInA, 48);
      vec16 pixelF_11 = load_vec_u8(dmemInB, 48);
      vec16 pixelF_21 = load_vec_u8(dmemInC, 48);

      vec16 sum0, sum1, sum2, sum3, sum4, sum5;
      {
        vec16 pixelC_01 = load_vec_u8(dmemInA, 24);
        vec16 pixelC_11 = load_vec_u8(dmemInB, 24);
        vec16 pixelC_21 = load_vec_u8(dmemInC, 24);

        vec16 pixelD_01 = load_vec_u8(dmemInA, 32);
        vec16 pixelD_11 = load_vec_u8(dmemInB, 32);
        vec16 pixelD_21 = load_vec_u8(dmemInC, 32);

        vec16 pixelE_01 = load_vec_u8(dmemInA, 40);
        vec16 pixelE_11 = load_vec_u8(dmemInB, 40);
        vec16 pixelE_21 = load_vec_u8(dmemInC, 40);

        sum0 = sum4x3(factor, pixelA_00, pixelA_10, pixelA_20, pixelA_01, pixelA_11, pixelA_21);
        sum1 = sum4x3(factor, pixelA_01, pixelA_11, pixelA_21, pixelB_01, pixelB_11, pixelB_21);
        sum2 = sum4x3(factor, pixelB_01, pixelB_11, pixelB_21, pixelC_01, pixelC_11, pixelC_21);
        sum3 = sum4x3(factor, pixelC_01, pixelC_11, pixelC_21, pixelD_01, pixelD_11, pixelD_21);
        sum4 = sum4x3(factor, pixelD_01, pixelD_11, pixelD_21, pixelE_01, pixelE_11, pixelE_21);
        sum5 = sum4x3(factor, pixelE_01, pixelE_11, pixelE_21, pixelF_01, pixelF_11, pixelF_21);
      }

      vec16 pixelG_01 = load_vec_u8(dmemInA, 56);
      vec16 pixelG_11 = load_vec_u8(dmemInB, 56);
      vec16 pixelG_21 = load_vec_u8(dmemInC, 56);

      vec16 pixelH_01 = load_vec_u8(dmemInA, 64);
      vec16 pixelH_11 = load_vec_u8(dmemInB, 64);
      vec16 pixelH_21 = load_vec_u8(dmemInC, 64);

      vec16 sum6 = sum4x3(factor, pixelF_01, pixelF_11, pixelF_21, pixelG_01, pixelG_11, pixelG_21);
      vec16 sum7 = sum4x3(factor, pixelG_01, pixelG_11, pixelG_21, pixelH_01, pixelH_11, pixelH_21);

      dmemOutCurr += 64;
/*
      sum0:ufract = sum0:ufract * sum0:ufract;
      sum1:ufract = sum1:ufract * sum1:ufract;
      sum2:ufract = sum2:ufract * sum2:ufract;
      sum3:ufract = sum3:ufract * sum3:ufract;
      sum4:ufract = sum4:ufract * sum4:ufract;
      sum5:ufract = sum5:ufract * sum5:ufract;
      sum6:ufract = sum6:ufract * sum6:ufract;
      sum7:ufract = sum7:ufract * sum7:ufract;
*/

      store_vec_u8(sum0, dmemOutCurr, -64);
      store_vec_u8(sum1, dmemOutCurr, -56);
      store_vec_u8(sum2, dmemOutCurr, -48);
      store_vec_u8(sum3, dmemOutCurr, -40);
      store_vec_u8(sum4, dmemOutCurr, -32);
      store_vec_u8(sum5, dmemOutCurr, -24);
      store_vec_u8(sum6, dmemOutCurr, -16);
      store_vec_u8(sum7, dmemOutCurr, -8);

      dmemInA += 64;
      dmemInB += 64;
      dmemInC += 64;

      pixelA_00 = load_vec_u8(dmemInA, 0);
      pixelA_10 = load_vec_u8(dmemInB, 0);
      pixelA_20 = load_vec_u8(dmemInC, 0);

      pixelA_01 = load_vec_u8(dmemInA, 8);
      pixelA_11 = load_vec_u8(dmemInB, 8);

      dmemOutEnd = dmemOutStart + BLUR_STRIDE;
      ptrRDRAMOut += 64;

    } while(dmemOutCurr != dmemOutEnd)

    dmaOutAsync(ptrRDRAMOut, dmemOutStart, dmaSize);
    loadNextImageLine(ptrRDRAMIn, dmaSize);

  } while(ptrRDRAMIn != ptrRDRAMInEnd)
}

macro sum4x2_X(
  vec16 a, vec16 b, vec16 c, vec16 d
)
{
  a:sfract = a:sfract * sumFactor:sfract.x;
  a:sfract = b:sfract +* sumFactor:sfract.x;
  a:sfract = c:sfract +* sumFactor:sfract.x;
  a:sfract = d:sfract +* sumFactor:sfract.x;
}

macro sum4x2_Y_Mem(vec16 res, vec16 a)
{
  res.xyzw = a.XYZW;
  res:sint = res:sint + a:sint;
}

command<2> Cmd_Downscale(u32 ptrRDRAMIn, u32 prtRDRAMOut)
{
  ptrRDRAMIn += SCREEN_STRIDE;
  u32 ptrRDRAMInEnd = ptrRDRAMIn + BUFF_SIZE_RGBA32;

  prtRDRAMOut -= BLUR_STRIDE;

  u16 dmaSizeIn = (
    (SCREEN_STRIDE << 20) // skip
    | (1 << 12) // rows
    | (SCREEN_STRIDE - 1) // size
  );
  u16 dmaSizeOut = BLUR_STRIDE - 1;

  vec16 sumFactor;
  sumFactor:sfract.x = 0.125;

  u16 dmemOutA = BUFF_BLOOM;
  u16 dmemOutB = BUFF_BLOOM_B;
  u16 dmemOut;

  loop {
    u16 dmemInA, dmemInB;
    u16 dmemOutEnd;

    loop {
      RA = get_dma_busy();
      dmemInA = BUFF_IN_A;
      dmemInB = BUFF_IN_B;
    } while(RA != 0)

    // Load next source-image lines, while we do a 4-to-1 scale
    // we skip every second line and only LERP two later one
    dmaInAsync(ptrRDRAMIn, dmemInA, dmaSizeIn);
    ptrRDRAMIn += SCREEN_STRIDE * 4;

    loop {
      RA = get_dma_busy();

      dmemOut = dmemOutA;
      dmemOutEnd = dmemOut + BLUR_STRIDE;
    } while(RA != 0)

    dmaOutAsync(prtRDRAMOut, dmemOutB, dmaSizeOut);
    swap(dmemOutA, dmemOutB);

    vec16 resA, resB;
    vec16 p0_AB, p0_CD, p0_EF, p0_GH;
    vec16 p1_AB, p1_CD, p1_EF, p1_GH;
    vec16 p2_AB, p2_CD, p2_EF, p2_GH;
    vec16 p3_AB, p3_CD, p3_EF, p3_GH;

    loop {
      resA:sint = p0_AB:sint + p1_AB:sint;
      resB:sint = p2_AB:sint + p3_AB:sint;

      store_vec_u8(resA, dmemOut, -16);
      store_vec_u8(resB, dmemOut, -8);

      /**
       * This Loads 4x2 Pixels like so:
       * [A] [B] [C] [D]
       * [E] [F] [G] [H]
       */
      p0_AB = load_vec_u8(dmemInA, 0);
      p0_CD = load_vec_u8(dmemInA, 8);
      p0_EF = load_vec_u8(dmemInB, 0);
      p0_GH = load_vec_u8(dmemInB, 8);

      p1_AB = load_vec_u8(dmemInA, 16);
      p1_CD = load_vec_u8(dmemInA, 24);
      p1_EF = load_vec_u8(dmemInB, 16);
      p1_GH = load_vec_u8(dmemInB, 24);

      p2_AB = load_vec_u8(dmemInA, 32);
      p2_CD = load_vec_u8(dmemInA, 40);
      p2_EF = load_vec_u8(dmemInB, 32);
      p2_GH = load_vec_u8(dmemInB, 40);

      p3_AB = load_vec_u8(dmemInA, 48);
      p3_CD = load_vec_u8(dmemInA, 56);
      p3_EF = load_vec_u8(dmemInB, 48);
      p3_GH = load_vec_u8(dmemInB, 56);

     /**
      * take average in groups of 2 pixels at once:
      * [A] [B] [C] [D]
      * [E] [F] [G] [H] -> [ACEG] [BDFH]
      */
      sum4x2_X(p0_AB, p0_CD, p0_EF, p0_GH);
      sum4x2_X(p1_AB, p1_CD, p1_EF, p1_GH);
      sum4x2_X(p2_AB, p2_CD, p2_EF, p2_GH);
      sum4x2_X(p3_AB, p3_CD, p3_EF, p3_GH);

      @Barrier("tmp0") store(p0_AB.XYZW, dmemInA, 0);
      @Barrier("tmp0") p0_AB.X = p1_AB.x;
      @Barrier("tmp0") p0_AB.Y = p1_AB.y;
      @Barrier("tmp0") p0_AB.Z = p1_AB.z;
      @Barrier("tmp0") p1_AB.xyzw = load(dmemInA, 0).xyzw;

      @Barrier("tmp1") store(p2_AB.XYZW, dmemInA, 8);
      @Barrier("tmp1") p2_AB.X = p3_AB.x;
      @Barrier("tmp1") p2_AB.Y = p3_AB.y;
      @Barrier("tmp1") p2_AB.Z = p3_AB.z;
      @Barrier("tmp1") p3_AB.xyzw = load(dmemInA, 8).xyzw;

      dmemOut += 16;
      dmemInA += 64;
      dmemInB += 64;
      prtRDRAMOut += 16;

    } while(dmemOut != dmemOutEnd)

    resA:sint = p0_AB:sint + p1_AB:sint;
    resB:sint = p2_AB:sint + p3_AB:sint;

    store_vec_u8(resA, dmemOut, -16);
    store_vec_u8(resB, dmemOut, -8);

  } while(ptrRDRAMIn != ptrRDRAMInEnd)

  dmaOutAsync(prtRDRAMOut, dmemOutB, dmaSizeOut);
}