include "rsp_queue.inc"

#define SCREEN_WIDTH 320
#define SCREEN_HEIGHT 240
#define SCREEN_STRIDE (SCREEN_WIDTH * 4)
#define BUFF_SIZE_RGBA16 (SCREEN_WIDTH * SCREEN_HEIGHT * 2)
#define BUFF_SIZE_RGBA32 (SCREEN_WIDTH * SCREEN_HEIGHT * 4)

#define BLUR_WIDTH 80
#define BLUR_HEIGHT 60
#define BLUR_STRIDE (BLUR_WIDTH * 4)
#define BLUR_STRIDE_PADDED (BLUR_WIDTH * 4 + 32)

bss {
  u32 BUFF_IN_A[SCREEN_WIDTH];
  u32 BUFF_IN_B[SCREEN_WIDTH];

  alignas(8)
  vec16 SAFE_SPACE_0;
  u32 BUFF_BLOOM[BLUR_WIDTH];
  vec16 SAFE_SPACE_1;
  vec16 SAFE_SPACE_2;
  u32 BUFF_BLOOM_B[BLUR_WIDTH];
  vec16 SAFE_SPACE_3;
}

// DMA from RDRAM into DMEM
macro dmaInAsync(u32 addrRDRAM, u32 addrDMEM, u32 size)
{
  @Barrier("DMA") set_dma_addr_rsp(addrDMEM);
  @Barrier("DMA") set_dma_addr_rdram(addrRDRAM);
  @Barrier("DMA") set_dma_read(size);
}

// DMA from DMEM into RDRAM
macro dmaOutAsync(u32 addrRDRAM, u32 addrDMEM, u32 size)
{
  @Barrier("DMA") set_dma_addr_rsp(addrDMEM);
  @Barrier("DMA") set_dma_addr_rdram(addrRDRAM);
  @Barrier("DMA") set_dma_write(size);
}

 macro dmaAwait()
 {
   loop {
    RA = get_dma_busy();
    // DELAY SLOT
  } while(RA != 0)
 }

macro packRGBA16(vec16 out, vec16 in)
{
  out = in * 2;
  out = VCONST_G +* in.yyyyYYYY;
  out = VCONST_R +* in.xxxxXXXX;
}

command<0> Cmd_HDRBloom(u32 ptrIn, u32 ptrOut, u32 ptrBloom, u16 factor)
{
  vec16 VCONST_R = 1 << 11;
  vec16 VCONST_G = 1 << 6;

  dma_await();

  u32 ptrInEnd = ptrIn + BUFF_SIZE_RGBA32;
  u16 buffDMEM = BUFF_IN_A;
  u8 bloomPhase = 0;
  //ptrBloom -= 8;
  //ptrBloom += BLUR_STRIDE;

  vec16 bloomFactorY = 0;
  vec16 bloomFactorA = 0;
  bloomFactorA:sfract.X = 0.25;
  bloomFactorA:sfract.Y = bloomFactorA:sfract.X;
  bloomFactorA:sfract.Z = bloomFactorA:sfract.X;

  bloomFactorA.w = factor;

  vec16 bloomFactorB;
  bloomFactorB:sfract.x = 0.5;
  bloomFactorB:sfract.y = bloomFactorB:sfract.x;
  bloomFactorB:sfract.z = bloomFactorB:sfract.x;
  bloomFactorB:sfract.X = 0.75;
  bloomFactorB:sfract.Y = bloomFactorB:sfract.X;
  bloomFactorB:sfract.Z = bloomFactorB:sfract.X;

  loop {
    u32 dmaSize = SCREEN_STRIDE - 1;
    u32 ptrDMEM = buffDMEM;

    dmaInAsync(ptrIn, ptrDMEM, dmaSize);

    u16 dmemBloom = BUFF_BLOOM;
    u16 bloomDmaSize = BLUR_STRIDE*2;

    if(bloomPhase == 0) {
      loop {
        RA = get_dma_busy();
        bloomPhase = 4; // DELAY SLOT
        bloomFactorY = VZERO - 0x2000;
      } while(RA != 0)

      dmaInAsync(ptrBloom, dmemBloom, bloomDmaSize);
      ptrBloom += BLUR_STRIDE;
    }
    bloomPhase -= 1;

    ptrIn += SCREEN_STRIDE;

    u16 tmpMem = SAFE_SPACE_3;

    u32 dmemIn, dmemOut;
    u32 dmemInEnd;

    bloomFactorY += 0x2000;

    loop {
      RA = get_dma_busy();
      dmemOut = BUFF_IN_B;
      dmemIn = ptrDMEM;
      dmemInEnd = dmemIn + SCREEN_WIDTH*4;
    } while(RA != 0)

    vec16 bloom0, bloom1, bloom2, bloom3;
    vec16 bloom0Next, bloom2Next;

    vec16 pixelOut0, pixelOut1, pixelOut2, pixelOut3;

    bloom0 = load_vec_u8(dmemBloom, 0);
    bloom0Next = load_vec_u8(dmemBloom, 320);

    dmemBloom += 4;

    bloom2 = load_vec_u8(dmemBloom, 0);
    bloom2Next = load_vec_u8(dmemBloom, 320);

    vec16 diffY_A = bloom0Next - bloom0;
    vec16 diffY_B = bloom2Next - bloom2;

    vec16 pixel0 = load_vec_u8(dmemIn, 0);

    loop {
      vec16 pixel1 = load_vec_u8(dmemIn, 8);
      vec16 pixel2 = load_vec_u8(dmemIn, 16);
      vec16 pixel3 = load_vec_u8(dmemIn, 24);

      store(pixelOut0.z, dmemOut, -16);
      store(pixelOut0.Z, dmemOut, -14);
      store(pixelOut1.z, dmemOut, -12);
      store(pixelOut1.Z, dmemOut, -10);
      store(pixelOut2.z, dmemOut, -8);
      store(pixelOut2.Z, dmemOut, -6);
      store(pixelOut3.z, dmemOut, -4);
      store(pixelOut3.Z, dmemOut, -2);

      dmemBloom += 4;

      // interpolate vertically
      bloom0:sint = bloom0:sint * 1;
      bloom0:sfract = diffY_A:sfract +* bloomFactorY:sfract;

      pixel0 >>= 6;

      bloom2:sint = bloom2:sint * 1;
      bloom2:sfract = diffY_B:sfract +* bloomFactorY:sfract;

      // bloom0 now contains 2 pixels in xyzw and XYZW, so viewing the register as two halves: [A, B]
      // in order to do horizontal interpolation we have to LERP 3 values in between A and B (X0, X1, X2)
      // and organize the data so that that span across 2 registers to be added onto the color value later on
      // So we need to transform [A,B] into [A, X0] [X1, X2], B gets thrown away since it is the next starting pixel
      @Barrier("tmp_1") bloom0Next = bloom0;
      @Barrier("tmp_0") store(bloom0, tmpMem, 0);
      @Barrier("tmp_1") @Barrier("tmp_0") bloom0.XYZW = load(tmpMem, 0).xyzw;
      @Barrier("tmp_0") bloom0Next.xyzw = load(tmpMem, 0).XYZW;

      pixel1 >>= 6;
      pixel2 >>= 6;
      pixel3 >>= 6;

      @Barrier("tmp_3") bloom2Next = bloom2; // bloom2Next is the next pixel in the row, so it is the one that will be added to the color
      @Barrier("tmp_2") store(bloom2, tmpMem, 16);
      @Barrier("tmp_3") @Barrier("tmp_2") bloom2.XYZW = load(tmpMem, 16).xyzw;
      @Barrier("tmp_2") bloom2Next.xyzw = load(tmpMem, 16).XYZW;

      vec16 diffX_A = bloom0Next - bloom0;

      pixel0:sint *= bloomFactorA.w;
      pixel1:sint *= bloomFactorA.w;

      bloom1:sint = bloom0:sint * 1;
      bloom1:sfract = diffX_A:sfract +* bloomFactorB:sfract;

      vec16 diffX_B = bloom2Next - bloom2;

      bloom0:sint = bloom0:sint * 1;
      bloom0:sfract = diffX_A:sfract +* bloomFactorA:sfract;

      bloom3:sint = bloom2:sint * 1;
      bloom3:sfract = diffX_B:sfract +* bloomFactorB:sfract;

      bloom2:sint = bloom2:sint * 1;
      bloom2:sfract = diffX_B:sfract +* bloomFactorA:sfract;

      pixel2:sint *= bloomFactorA.w;
      pixel3:sint *= bloomFactorA.w;

      pixel0:sint += bloom0:sint;
      pixel1:sint += bloom1:sint;
      pixel2:sint += bloom2:sint;
      pixel3:sint += bloom3:sint;

      pixel0 >>= 10;
      pixel1 >>= 10;
      pixel2 >>= 10;
      pixel3 >>= 10;

      pixelOut2 = packRGBA16(pixel2);
      pixelOut3 = packRGBA16(pixel3);
      pixelOut0 = packRGBA16(pixel0);
      pixelOut1 = packRGBA16(pixel1);

      bloom0 = load_vec_u8(dmemBloom, 0);
      bloom0Next = load_vec_u8(dmemBloom, 320);

      dmemBloom += 4;

      bloom2 = load_vec_u8(dmemBloom, 0);
      bloom2Next = load_vec_u8(dmemBloom, 320);

      diffY_A = bloom0Next - bloom0;
      diffY_B = bloom2Next - bloom2;

      dmemIn += 32;
      dmemOut += 16;

      pixel0 = load_vec_u8(dmemIn, 0);

    } while(dmemIn != dmemInEnd)

    store(pixelOut0.z, dmemOut, -16);
    store(pixelOut0.Z, dmemOut, -14);
    store(pixelOut1.z, dmemOut, -12);
    store(pixelOut1.Z, dmemOut, -10);
    store(pixelOut2.z, dmemOut, -8);
    store(pixelOut2.Z, dmemOut, -6);
    store(pixelOut3.z, dmemOut, -4);
    store(pixelOut3.Z, dmemOut, -2);

    u32 dmaSize = (SCREEN_WIDTH * 2) - 1;
    ptrDMEM = dmemOut - SCREEN_WIDTH * 2;
    dmaOutAsync(ptrOut, ptrDMEM, dmaSize);

    ptrOut += (SCREEN_WIDTH * 2);
  } while(ptrIn != ptrInEnd)
}

macro loadNextImageLine(u32 ptrRDRAMIn, u16 dmaSize)
{
  lastLoadedDmemIn = dmemInOffset + BUFF_IN_A;
  dmaInAsync(ptrRDRAMIn, lastLoadedDmemIn, dmaSize);
  dmemInOffset += BLUR_STRIDE_PADDED;

  if(ptrRDRAMIn != ptrRDRAMInEnd) {
    ptrRDRAMIn += BLUR_STRIDE;
  }

  if(dmemInOffset == dmemInOffsetEnd) {
    dmemInOffset = 0;
  }
}

macro sum4x3(
  vec16 sum, vec16 factor,
  vec16 pixel00, vec16 pixel10, vec16 pixel20,
  vec16 pixel01, vec16 pixel11, vec16 pixel21
)
{
  sum:ufract = pixel00:ufract *  factor:ufract.x;
  sum:ufract = pixel10:ufract +* factor:ufract.x;
  sum:ufract = pixel20:ufract +* factor:ufract.x;

  sum:ufract = pixel01:ufract +* factor:ufract.x;
  sum:ufract = pixel11:ufract +* factor:ufract.x;
  sum:ufract = pixel21:ufract +* factor:ufract.x;
}

command<1> Cmd_Blur(u32 ptrRDRAMIn, u32 ptrRDRAMOut, u16 brightness)
{
  u32 ptrRDRAMInEnd = ptrRDRAMIn + (BLUR_STRIDE * (BLUR_HEIGHT - 1));
  u32 rowsLeft = BLUR_HEIGHT;

  u16 dmaSize = (BLUR_WIDTH * 4) - 1;
  u16 dmemInOffset = 0;
  u16 dmemInOffsetEnd = BLUR_STRIDE_PADDED * 3;

  // @TODO: use proper kernel(?) | uses 2 register(?)
  vec16 factor;
  factor.x = brightness;

  u16 dmemInA = BUFF_IN_A;
  u32 dmemOutStart = dmemInA + (BLUR_STRIDE_PADDED*3);

  u16 lastLoadedDmemIn = dmemInA;

  dmaAwait();

  // Preload the first 3 lines, since we clamp this is two times the first one
  // and lastly the second row
  dmaInAsync(ptrRDRAMIn, dmemInA, dmaSize);
  dmemInA += BLUR_STRIDE_PADDED;
  dmaInAsync(ptrRDRAMIn, dmemInA, dmaSize);
  dmemInA += BLUR_STRIDE_PADDED;

  ptrRDRAMIn += BLUR_STRIDE;
  dmaAwait();

  dmaInAsync(ptrRDRAMIn, dmemInA, dmaSize);
  ptrRDRAMIn += BLUR_STRIDE;
  dmaAwait();

  // dupe the last pixel of all 3 rows, to safely sample OOB
  u32 tmp1 = load(dmemInA, 316);
  store(tmp1, dmemInA, 320);

  dmemInA -= BLUR_STRIDE_PADDED;
  u32 tmp2 = load(dmemInA, 316);
  store(tmp2, dmemInA, 320);

  // last pixel is handled in the loop each iteration

  undef tmp1;
  undef tmp2;

  loop {
    dmemInA = BUFF_IN_A;
    dmemInA -= 4;

    u16 dmemInC = dmemInA + BLUR_STRIDE_PADDED*2;

    u32 dmemOutCurr, dmemOutEnd;

    loop {
      RA = get_dma_busy();
      dmemOutCurr = dmemOutStart; // DELAY SLOT
    } while(RA != 0)

    // pre-load the first pixels
    // Note that the offsets here are adjusted to the right to no sample OOB
    // the next time this is loaded in the loop the offset it correct
    vec16 pixelA_00 = load_vec_u8(dmemInA, 8);
    vec16 pixelA_10 = load_vec_u8(dmemInA, 360);
    vec16 pixelA_20 = load_vec_u8(dmemInC, 8);

    vec16 pixelA_01 = load_vec_u8(dmemInA, 8);
    vec16 pixelA_11 = load_vec_u8(dmemInA, 360);

    { // dupe the last pixel one beyond to safely sample OOB
      u32 tmp1 = load(lastLoadedDmemIn, 316);
      store(tmp1, lastLoadedDmemIn, 320);
    }

    loop {
      u16 dmemInB = dmemInA + BLUR_STRIDE_PADDED;

      vec16 pixelA_21 = load_vec_u8(dmemInC, 8);

      vec16 pixelB_01 = load_vec_u8(dmemInA, 16);
      vec16 pixelB_11 = load_vec_u8(dmemInB, 16);
      vec16 pixelB_21 = load_vec_u8(dmemInC, 16);

      vec16 pixelF_01 = load_vec_u8(dmemInA, 48);
      vec16 pixelF_11 = load_vec_u8(dmemInB, 48);
      vec16 pixelF_21 = load_vec_u8(dmemInC, 48);

      vec16 sum0, sum1, sum2, sum3, sum4, sum5;
      {
        vec16 pixelC_01 = load_vec_u8(dmemInA, 24);
        vec16 pixelC_11 = load_vec_u8(dmemInB, 24);
        vec16 pixelC_21 = load_vec_u8(dmemInC, 24);

        vec16 pixelD_01 = load_vec_u8(dmemInA, 32);
        vec16 pixelD_11 = load_vec_u8(dmemInB, 32);
        vec16 pixelD_21 = load_vec_u8(dmemInC, 32);

        vec16 pixelE_01 = load_vec_u8(dmemInA, 40);
        vec16 pixelE_11 = load_vec_u8(dmemInB, 40);
        vec16 pixelE_21 = load_vec_u8(dmemInC, 40);

        sum0 = sum4x3(factor, pixelA_00, pixelA_10, pixelA_20, pixelA_01, pixelA_11, pixelA_21);
        sum1 = sum4x3(factor, pixelA_01, pixelA_11, pixelA_21, pixelB_01, pixelB_11, pixelB_21);
        sum2 = sum4x3(factor, pixelB_01, pixelB_11, pixelB_21, pixelC_01, pixelC_11, pixelC_21);
        sum3 = sum4x3(factor, pixelC_01, pixelC_11, pixelC_21, pixelD_01, pixelD_11, pixelD_21);
        sum4 = sum4x3(factor, pixelD_01, pixelD_11, pixelD_21, pixelE_01, pixelE_11, pixelE_21);
        sum5 = sum4x3(factor, pixelE_01, pixelE_11, pixelE_21, pixelF_01, pixelF_11, pixelF_21);
      }

      vec16 pixelG_01 = load_vec_u8(dmemInA, 56);
      vec16 pixelG_11 = load_vec_u8(dmemInB, 56);
      vec16 pixelG_21 = load_vec_u8(dmemInC, 56);

      vec16 pixelH_01 = load_vec_u8(dmemInA, 64);
      vec16 pixelH_11 = load_vec_u8(dmemInB, 64);
      vec16 pixelH_21 = load_vec_u8(dmemInC, 64);

      vec16 sum6 = sum4x3(factor, pixelF_01, pixelF_11, pixelF_21, pixelG_01, pixelG_11, pixelG_21);
      vec16 sum7 = sum4x3(factor, pixelG_01, pixelG_11, pixelG_21, pixelH_01, pixelH_11, pixelH_21);

      dmemOutCurr += 64;

      store_vec_u8(sum0, dmemOutCurr, -64);
      store_vec_u8(sum1, dmemOutCurr, -56);
      store_vec_u8(sum2, dmemOutCurr, -48);
      store_vec_u8(sum3, dmemOutCurr, -40);
      store_vec_u8(sum4, dmemOutCurr, -32);
      store_vec_u8(sum5, dmemOutCurr, -24);
      store_vec_u8(sum6, dmemOutCurr, -16);
      store_vec_u8(sum7, dmemOutCurr, -8);

      dmemInA += 64;
      dmemInB += 64;
      dmemInC += 64;

      pixelA_00 = load_vec_u8(dmemInA, 0);
      pixelA_10 = load_vec_u8(dmemInB, 0);
      pixelA_20 = load_vec_u8(dmemInC, 0);

      pixelA_01 = load_vec_u8(dmemInA, 8);
      pixelA_11 = load_vec_u8(dmemInB, 8);

      dmemOutEnd = dmemOutStart + BLUR_STRIDE;
      ptrRDRAMOut += 64;

    } while(dmemOutCurr != dmemOutEnd)

    dmaOutAsync(ptrRDRAMOut, dmemOutStart, dmaSize);
    loadNextImageLine(ptrRDRAMIn, dmaSize);
    rowsLeft -= 1;

  } while(rowsLeft != 0)
}

macro sum4x2_X(
  vec16 a, vec16 b, vec16 c, vec16 d
)
{
  a:sfract = a:sfract * sumFactor:sfract.x;
  a:sfract = b:sfract +* sumFactor:sfract.x;
  a:sfract = c:sfract +* sumFactor:sfract.x;
  a:sfract = d:sfract +* sumFactor:sfract.x;
}

macro sum4x2_Y_Mem(vec16 res, vec16 a)
{
  res.xyzw = a.XYZW;
  res:sint = res:sint + a:sint;
}

command<2> Cmd_Downscale(u32 ptrRDRAMIn, u32 prtRDRAMOut)
{
  //ptrRDRAMIn += SCREEN_STRIDE;
  u32 ptrRDRAMInEnd = ptrRDRAMIn + BUFF_SIZE_RGBA32;

  prtRDRAMOut -= BLUR_STRIDE;

  u16 dmaSizeIn = (
    (SCREEN_STRIDE << 20) // skip
    | (1 << 12) // rows
    | (SCREEN_STRIDE - 1) // size
  );
  u16 dmaSizeOut = BLUR_STRIDE - 1;

  vec16 sumFactor;
  sumFactor:sfract.x = 0.125;

  u16 dmemOutA = BUFF_BLOOM;
  u16 dmemOutB = BUFF_BLOOM_B;
  u16 dmemOut;

  loop {
    u16 dmemInA, dmemInB;
    u16 dmemOutEnd;

    loop {
      RA = get_dma_busy();
      dmemInA = BUFF_IN_A;
      dmemInB = BUFF_IN_B;
    } while(RA != 0)

    // Load next source-image lines, while we do a 4-to-1 scale
    // we skip every second line and only LERP two later one
    dmaInAsync(ptrRDRAMIn, dmemInA, dmaSizeIn);
    ptrRDRAMIn += SCREEN_STRIDE * 4;

    loop {
      RA = get_dma_busy();

      dmemOut = dmemOutA;
      dmemOutEnd = dmemOut + BLUR_STRIDE;
    } while(RA != 0)

    dmaOutAsync(prtRDRAMOut, dmemOutB, dmaSizeOut);
    swap(dmemOutA, dmemOutB);

    // dupe last pixel
    {
      dmemInA += 1280;
      dmemInB += 1280;

      vec16 a = load(dmemInA, -32);
      store(a, dmemInA, -16);

      dmemInA -= 1280;
      dmemInB -= 1280;
    }

    vec16 resA, resB;
    vec16 p0_AB, p0_CD, p0_EF, p0_GH;
    vec16 p1_AB, p1_CD, p1_EF, p1_GH;
    vec16 p2_AB, p2_CD, p2_EF, p2_GH;
    vec16 p3_AB, p3_CD, p3_EF, p3_GH;

    loop {
      resA:sint = p0_AB:sint + p1_AB:sint;
      resB:sint = p2_AB:sint + p3_AB:sint;

      store_vec_u8(resA, dmemOut, -16);
      store_vec_u8(resB, dmemOut, -8);

      /**
       * This Loads 4x2 Pixels like so:
       * [A] [B] [C] [D]
       * [E] [F] [G] [H]
       */
      p0_AB = load_vec_u8(dmemInA, 0);
      p0_CD = load_vec_u8(dmemInA, 8);
      p0_EF = load_vec_u8(dmemInB, 0);
      p0_GH = load_vec_u8(dmemInB, 8);

      p1_AB = load_vec_u8(dmemInA, 16);
      p1_CD = load_vec_u8(dmemInA, 24);
      p1_EF = load_vec_u8(dmemInB, 16);
      p1_GH = load_vec_u8(dmemInB, 24);

      p2_AB = load_vec_u8(dmemInA, 32);
      p2_CD = load_vec_u8(dmemInA, 40);
      p2_EF = load_vec_u8(dmemInB, 32);
      p2_GH = load_vec_u8(dmemInB, 40);

      p3_AB = load_vec_u8(dmemInA, 48);
      p3_CD = load_vec_u8(dmemInA, 56);
      p3_EF = load_vec_u8(dmemInB, 48);
      p3_GH = load_vec_u8(dmemInB, 56);

     /**
      * take average in groups of 2 pixels at once:
      * [A] [B] [C] [D]
      * [E] [F] [G] [H] -> [ACEG] [BDFH]
      */
      sum4x2_X(p0_AB, p0_CD, p0_EF, p0_GH);
      sum4x2_X(p1_AB, p1_CD, p1_EF, p1_GH);
      sum4x2_X(p2_AB, p2_CD, p2_EF, p2_GH);
      sum4x2_X(p3_AB, p3_CD, p3_EF, p3_GH);

      @Barrier("tmp0") store(p0_AB.XYZW, dmemInA, 0);
      @Barrier("tmp0") p0_AB.X = p1_AB.x;
      @Barrier("tmp0") p0_AB.Y = p1_AB.y;
      @Barrier("tmp0") p0_AB.Z = p1_AB.z;
      @Barrier("tmp0") p1_AB.xyzw = load(dmemInA, 0).xyzw;

      @Barrier("tmp1") store(p2_AB.XYZW, dmemInA, 8);
      @Barrier("tmp1") p2_AB.X = p3_AB.x;
      @Barrier("tmp1") p2_AB.Y = p3_AB.y;
      @Barrier("tmp1") p2_AB.Z = p3_AB.z;
      @Barrier("tmp1") p3_AB.xyzw = load(dmemInA, 8).xyzw;

      dmemOut += 16;
      dmemInA += 64;
      dmemInB += 64;
      prtRDRAMOut += 16;

    } while(dmemOut != dmemOutEnd)

    resA:sint = p0_AB:sint + p1_AB:sint;
    resB:sint = p2_AB:sint + p3_AB:sint;

    store_vec_u8(resA, dmemOut, -16);
    store_vec_u8(resB, dmemOut, -8);

  } while(ptrRDRAMIn != ptrRDRAMInEnd)

  dmaOutAsync(prtRDRAMOut, dmemOutB, dmaSizeOut);
}